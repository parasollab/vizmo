/*
	\file BasePart.h
	\author  	
	\date Jan. 9, 03
	\ingroup stapl
	\brief Abstract base class to provide interfaces for each part, 
	which are essentially sequential containers 

	Due to redistribution/migration, each thread may 
	contain isolated sequential container pieces as part of 
	the pcontainer. BasePart class serves as an interface to all
	pContainer parts.
	
	Internal to stapl developer.
*/

#ifndef BASEPART_H
#define BASEPART_H
#include "splBaseElement.h"
#include "BaseDistribution.h"
namespace stapl {

/**
 * @addtogroup basepcontainer
  * @{
 **/

/**
 * Class definition
**/
template<class T, class ITERATOR, class CONST_ITERATOR, class ELEMENT_SET>
class BasePart{

 public:
  ///Part iterator.
  typedef ITERATOR iterator;
  ///Const part iterator.
  typedef CONST_ITERATOR const_iterator;

  typedef ELEMENT_SET Element_Set_type;

  ///Reference to the element.
  typedef T& reference;
  ///Value type.
  typedef T value_type;

 protected:
  //=======================================
  //data
  //=======================================
  ///Part identifier
  PARTID partid;
  
 public:
  ///Defyne type for BasePart
  void define_type(typer &t)  {
    t.local(partid);
  }


 public:
  //=======================================
  //constructors 
  //=======================================
  ///Default constructor.
  BasePart() : partid(-1) {}
  BasePart(int m, const vector<GID>& _gidvec, const T& _data) {}
  BasePart(int m, const vector<GID>& _gidvec) {}
  ///Copy constructor.
  BasePart(PARTID _id) : partid(_id) {}
  
  //Destructor.
  virtual ~BasePart() {}

  //=======================================
  //Id and size methods
  //=======================================
  /**@brief Return Part identifier.
   *@return PARTID identifier for the current part.
   */
  virtual PARTID GetPartId() const { return partid; }

  /**@brief Set the part identifier for the current part.
   *@param PARTID part identifier.
   */
  virtual void SetPartId(PARTID _id) { partid = _id; }

  /**@brief Get the GIDs stored in the current part.
   *@param vector<GID>& reference to the vector that will be filled with the GIDs
   *stored inside this part.
   */
  virtual void GetPartGids(vector<GID>& _gidvec) const=0; 

  //=======================================
  //Element bookkeeping 
  //=======================================
  /**@brief Add element to part.
   *@param T the element to be added;
   *@param GID associated with the element. The GID is generated by the distribution. 
   */
  virtual void AddElement(const T& _t, GID _gid)  = 0;
  
  /* comment out the following pure virtual function,
     so in pArray, return type of "T" can be used. 
     (a requirement from valarray) */
/*   virtual const T& GetElement(GID _gid) const = 0; */

  //virtual T& GetElement(GID _gid) = 0;

  /**@brief Set the value of an existent element.
   *@param T the element to be added;
   *@param GID associated with the element. The GID is generated by the distribution. 
   */
  virtual void SetElement(GID _gid, const T& _t)   = 0;

  /**@brief Delete the element associated with the specified GID
   *@param GID identifier of the element to be deleted.
   */
  virtual void DeleteElement(GID _gid)   = 0;

  /**@brief Check if the given gid is local to the part.
   *@param GID identifier of the element to be searched.
   */
  virtual bool ContainElement(const GID _gid)   = 0;

  /**@brief Check if the given gid is local to the part.
   *@param iterator will be initialized with the location of the element.
   *@param GID identifier of the element to be searched.
   *@Note. this method should be called after we check if the element is local or not. 
   */
  virtual bool ContainElement(const GID _gid, iterator *)   = 0;

  // this is needed by the LinearOrderPContainer, which makes the assumption that all parts have an erase method  
  //  iterator erase(iterator)=0;


  //=======================================
  //Get Element_Set info to collect distribution info 
  //=======================================
  virtual Element_Set_type GetElementSet() const   = 0;

  //=======================================
  //begin and end
  //=======================================
  /// Return a part iterator pointing to the begining of the part.
  virtual iterator begin() = 0;
  /// Return a part const iterator pointing to the begining of the part.
  virtual const_iterator begin() const = 0;

  /// Return a part iterator pointing to the end of the part.
  virtual iterator end() = 0;

  /// Return a part const iterator pointing to the end of the part.
  virtual const_iterator end()const  = 0;
  //=======================================
  //statistics
  //=======================================
  /// Return the size of the part.
  virtual size_t size() const   = 0;

  /// Return if the part is empty or not.
  virtual bool empty() const = 0;

  ///Display the elements of the part.
  virtual void DisplayPart() const {
    cout<<"BasePart::DisplayPart() is called"<<endl;
  }

};

} //end namespace stapl
//@}
#endif
