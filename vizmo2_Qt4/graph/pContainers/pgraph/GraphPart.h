/*!
	\file GraphPart.h
	\author Gabriel Tanase	
	\date Jan. 9, 03
	\ingroup stapl
	\brief Wrapper arround sequential graph container

 	Internal to stapl developer. 
*/
#ifndef GraphPart_h
#define GraphPart_h

#include "runtime.h"
#include "Graph.h"
#include "../base/BasePart.h"
#include "../distribution/DistributionDefines.h"
#include "../pvector/VectorPart.h"


/** @addtogroup pgraph
 * @{
*/

namespace stapl{

/**
* Class GraphPart is more or less the sequential container from which it
* inherits. It extends the sequential container with methods required for 
* parallel container. Every part will be associated with a unique id. This 
* way a pcontainer may be composed from several parts. Also every element of the
* sequential container is augmented with an extra field called global identifier.
* This will help the pcontainer to keep track of the individual elements when 
* they will migrate across different processors;
*/
template <class VERTEX,class WEIGHT>

class GraphPart: public BasePart<VERTEX,
  typename vector<typename BaseGraph<VERTEX,WEIGHT>::Vertex>::iterator , 
  typename vector<typename BaseGraph<VERTEX,WEIGHT>::Vertex>::const_iterator, 
  vector<GID> >, 
  public BaseGraph<VERTEX,WEIGHT> {

public:
  ///Sequential graph from which the GraphPart is derived.
  typedef BaseGraph<VERTEX,WEIGHT>    GRAPH;
  typedef vector<GID>                 Element_Set_type;

  ///Iterator over the part's vertices
  typedef typename GRAPH::VI           iterator;

  ///Const iterator over the part's vertices
  typedef typename GRAPH::CVI          const_iterator;
  
  ///value type for GraphPart is the VERTEX type specified by the user.
  typedef typename GRAPH::value_type   value_type;

  ///Vertex type
  typedef typename GRAPH::Vertex       Vertex;

  typedef typename GRAPH::Vertex       BaseElement_type;

  typedef GRAPH Sequential_Container_type;
  //typedef GraphPart<VERTEX,WEIGHT> GraphPart_type;
  typedef GraphPart<VERTEX,WEIGHT> Container_type;

public:
  //=======================================
  //constructor / destructor
  //=======================================
  /**@brief Default constructor
   */
  GraphPart(){}

  /**@brief Constructor with part identifier specified.
   *@param PARTID the identifier for the newly created part.
  */
  GraphPart(PARTID _pid){
    this->partid = _pid;
  }

  /**@brief Copy constructor. The part id for current part will be set to _id
   *@param const Container_type& reference to the source part.
   *@param PARTID identifier for the part.
   */
  GraphPart(const Container_type& _part, PARTID _pid){
    //!!! check if the next line is OK
    //cout<<"CHECK!!!:::::NOT IMPLEMENTED\n"<<endl;
    *this = _part;
    this->partid = _pid;    
  }
  /**@brief Destructor
   */
  ~GraphPart(){
    this->EraseGraph();
  }
  /**@brief 
   *Define type for GraphPart
   */
  void define_type(typer &t)  {
    cout<<"ERROR::Method not yet implemented"<<endl;
  }

  //=======================================
  //operators
  //=======================================


  //=======================================
  //methods from BasePart
  //=======================================
  /**@brief Add vertex to part.
   *@param  const value_type&  user data that will be stored in the newly added vertex.
   *@param GID associated with the vertex. The GID is generated by the distribution. 
   */
  inline void AddElement(const value_type& _t, GID _gid) {
    this->AddVertex(_t,_gid);
  }
 
  /**@brief Add vertex to part.
   *@param  const Vertex& reference to the graph's vertex whose information will be added.
   *@param GID associated with the vertex. The GID is generated by the distribution. 
   */
  inline void AddElement(const Vertex& _v, GID _gid){
    cout<<"check AddElement(vertex) method for reference passing"<<endl;
    this->AddVertex(_v.data,_gid);
  }

  /**@brief Get user data from the vertex whose identifier is specified.
   *@param GID identifier for the vertex
   *@return const value_type& the user data associated with the specified vertex identifier.
   */
  inline const value_type& GetElement(GID _gid) const { 
    const_iterator it;
    if(ContainElement(_gid, &it)) return it->GetUserData();

    else{
      //generate exception
      //...
      //the following code is to avoid an warning generated by the compiler;
      //I propose to avoid this to return values from the method usiing a parameter;
      value_type* temp = new value_type;
      return *temp;
    }
  }

  /**@brief Get user data from the vertex whose identifier is specified.
   *@param GID identifier for the vertex
   *@return value_type& the user data associated with the specified vertex identifier.
   */
  inline value_type& GetElement(GID _gid) { 
    iterator it;
    if(ContainElement(_gid, &it)) return it->GetUserData();
    else{
      //generate exception
      //...
      //the following code is to avoid an warning generated by the compiler;
      //I propose to avoid this to return values from the method usiing a parameter;
      value_type* temp = new value_type;
      return *temp;
    }
  }

  /**@brief Set the value of an existent vertex.
   *@param value_type& reference to the user data to be added;
   *@param GID associated with the element. The GID is generated by the distribution. 
   */
  inline void SetElement(GID _gid, const value_type& _t) {
    iterator it;
    if(ContainElement(_gid, &it)) it->SetUserData(_t);
  }

  /**@brief Delete the vertex associated with the specified GID
   *@param GID identifier of the vertex to be deleted.
   */
  inline void DeleteElement(GID _gid) {
    this->DeleteVertex(_gid);
  }

  /**@brief Check if the given gid is local to the part.
   *@param GID identifier of the vertex to be searched.
   */
  inline bool ContainElement(GID _gid) {
    const_iterator it;
    return ContainElement(_gid,&it);
  }

  /**@brief Check if the vertex with the specified GID is local to the part.
   *@param iterator will be initialized with the location of the vertex.
   *@param GID identifier of the vertex to be searched.
   *@Note. this method should be called after we check if the element is local or not. 
   */
  inline bool ContainElement(GID _gid, iterator* _lit) {
    return this->IsVertex(_gid,_lit);
    /*    iterator vi;
	  if(this->IsVertex(_gid,&vi)){
	  *_lit = vi;
	  return true;
	  } 
	  #ifdef STAPL_DEBUG
	  cout<<"WARNING! cannot find element with gid: "<<_gid
	  <<" in part "<<this->partid<<endl;
	  #endif
	  return false;
    */
  }

  /**@brief Check if the vertex with the specified GID is local to the part.
   *@param iterator will be initialized with the location of the vertex.
   *@param GID identifier of the vertex to be searched.
   *@Note. this method should be called after we check if the element is local or not. 
   */
  inline bool ContainElement(GID _gid, const_iterator* _lit) const {
    const_iterator vi;
    //iterator* it = const_cast<iterator*>(_lit); 

    if(this->IsVertex(_gid,&vi)){
      *_lit = vi;
      return true;
    }
#ifdef STAPL_DEBUG
    cout<<"ERROR! cannot find element with gid: "<<_gid
	<<" in part "<<this->partid<<endl;
#endif
    return false;
  }


  /**@brief Check if the vertex with the specified data is local to the part.
   *@param iterator will be initialized with the location of the vertex.
   *@param VERTEX  identifier of the vertex data  to be searched.
   *@Note. this method should be called after we check if the element is local or not. 
   */
  inline bool ContainElement(VERTEX& _v, iterator* _lit) {
    return this->IsVertex(_v , _lit);
  }

  /**@brief Check if the vertex with the specified data is local to the part.
   *@param const_iterator will be initialized with the location of the vertex.
   *@param VERTEX  identifier of the vertex data  to be searched.
   *@Note. this method should be called after we check if the element is local or not. 
   */
  inline bool ContainElement(VERTEX& _v, const_iterator* _lit) const {
    return this->IsVertex(_v , _lit);
  }

  /**@brief Check if the vertex with the specified data is local to the part.
   *@param VERTEX  identifier of the vertex data  to be searched.
   */
  inline bool ContainElement(VERTEX& _v) {
    const_iterator it;
    return this->IsVertex(_v,&it);
  }

  /**
   *@brief Part iterator pointing to the begining of the part.
   *@return iterator 
   */
  inline iterator begin(){
    return iterator(GRAPH::begin()); 
  }

  /**@brief 
   *Part iterator pointing to the element after the last one in the part.
   *@return iterator 
   */
  inline iterator end(){
    return iterator(GRAPH::end());
  }

  /**@brief 
   *Part iterator pointing to the begining of the part.
   *@return const_iterator 
   */
  inline const_iterator begin() const {
    return const_iterator(GRAPH::begin()); 
    //return iterator(const_cast<iterator>(GRAPH::begin())); 
  }

  /**@brief 
   *Part iterator pointing to the element after the last one in the part.
   *@return const_iterator 
   */
  inline const_iterator end() const {
    return const_iterator(GRAPH::end());
    //return iterator(const_cast<iterator>(GRAPH::end()));
  }

  Element_Set_type GetElementSet() const{
    Element_Set_type temp;
    return temp;
  }
  
  inline void GetPartGids(vector<GID>& _gidvec) const { 
    //this->GetVertices(_gidvec);
  }

  /**@brief Size of the part.
   *@return size_t the size of the part.
   */
  inline size_t size() const{
    return GRAPH::GetVertexCount();
  }

  /**@brief 
   *Test if the part is empty or not.
   *@return true if the part is empty and false otherwise.
   */
  inline bool empty() const{
    return (GRAPH::GetVertexCount() == 0);
  }
  
  /*@brief 
   *Delete all the vertices.
   */
  inline void clear(){
    this->v.clear();
  }


  //=======================================
  //methods reimplemented from Graph
  //=======================================
  void SimpleDeleteAllEdgesToV(VID _v2id) {
    for (iterator vi = this->begin(); vi != this->end(); vi++) {
      this->numEdges -= vi->DeleteXEdges(_v2id,-1);
    }
  }

  //to be fixed if we get rid of global iterator
  void SimpleDeleteVertex(VID _v2id) {
    for (iterator vi = this->v.begin(); vi != this->v.end(); vi++) {
      if(vi->vid == _v2id){
	this->v.erase(vi);
	return;
      }
    }
  }

  void resize(int _nsize) {
    this->v.resize(_nsize);
  }

};//end class GraphPart
}//end namespace stapl
//@}
#endif
