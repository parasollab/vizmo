//*****************************************************************************
// The following are documentation stubs for classes used by pAlgorithms and
// pContainers, which are defined by STL.  They are here mainly to help those 
// unfamiliar with STL.
//
// It is important to use these exact names in STAPL source code that uses
// the corresponding STL code.  This allows Doxygen to automatically create
// a link to the STL components for users that don't know STL that well.
//*****************************************************************************

/**
 * @defgroup stlReference Brief STL Overview
 *
 * STL is the ANSI/ISO approved standard template library for C++.  It
 * provides a set of fundamental, yet generic, data structures, called \e
 * containers, and \e algorithms.  It makes extensive use of C++ templates in
 * order to provide data type generality.  In addition, most of the algorithms
 * operate on many or all of the containers, and this interaction is
 * abstracted through the use of \e iterators.  \e Function \e objects are
 * provided and allow the basic operations of an algorithm or container to be
 * adjusted or optimized for a certain data type or desired result.  \e
 * Adaptors exist for changing the interface of containers, iterators, and
 * function objects.  Finally, memory allocation is abstracted and handled
 * through \e allocators.
 *
 * STAPL provides parallel versions of STL's containers (\ref pContainers) and
 * algorithms (\ref pAlgorithms).  The iterator concept has been expanded for
 * parallelism (\ref pRange).  However, many algorithms still utilize
 * iterators, so a short reference is provided (\ref iterators).  There is no
 * parallel equivalent for function objects, although they are often used by
 * algorithms, so a short reference is provided for them as well (\ref
 * functionObjects).
 *
 * STL is a very powerful means of programming, and allows complicated
 * programs to be expressed quickly and elegantly.  A number of excellent
 * books are available.  We recommend <b>STL Tutorial and Reference Guide,
 * Second Edition</b>, by Musser, Derge and Saini.  SGI also provides a free
 * overview and reference of STL at http://www.sgi.com/tech/stl/ .
 * @{
 **/

/**
 * @defgroup iterators Iterators
 * An \e iterator is the STL generalization of a pointer used for traversing,
 * reading, and writing a sequence of data.  It is a key provider of STL's
 * generality because it abstracts the connection between algorithms and
 * containers.  There are five types of iterators, arranged hierarchically:
 * InputIterator, OutputIterator, ForwardIterator, BiDirectionalIterator, and
 * RandomAccessIterator.  More advanced types of iterators may be used when
 * only a simple type is required (e.g., BiDirectionalIterator may be used
 * when only an InputIterator is requested).
 *
 * \see
 * \ref iterators, http://www.sgi.com/tech/stl/Iterators.html
 * @{
 **/

/**
 * An \e input \e iterator is the STL concept of an iterator that may be
 * tested for equality (\c ==, \c !=), dereferenced for reading (\c *i)
 * although not necessarily for writing, and that may be incremented to obtain
 * the next iterator in a sequence (\c i++, \c ++i).
 *
 * \see
 * \ref iterators, http://www.sgi.com/tech/stl/InputIterator.html
 **/
class InputIterator {};

/**
 * An \e output \e iterator is the STL concept of an iterator that may be
 * dereferenced for writing (\c *i) although not necessarily reading, and that
 * may be incremented to obtain the next iterator in a sequence (\c i++, \c
 * ++i).
 *
 * \see
 * \ref iterators, http://www.sgi.com/tech/stl/OutputIterator.html
 **/
class OutputIterator {};

/**
 * A \e forward \e iterator is the STL concept of an iterator, similar to both
 * the InputIterator and OutputIterator.  It may also be used in multipass
 * algorithms because its original position may be saved and reused for
 * additional traversals.
 *
 * \see
 * \ref iterators, http://www.sgi.com/tech/stl/ForwardIterator.html
 **/
class ForwardIterator : public InputIterator, public OutputIterator {};

/**
 * A \e bidirectional \e iterator is the STL concept of an iterator that is
 * similar to a ForwardIterator, but may be decremented (\c i--, \c --i) in
 * addition to incremented (\c i++, \c ++i) in order to obtain the next
 * iterator in a sequence.
 *
 * \see
 * \ref iterators, http://www.sgi.com/tech/stl/BidirectionalIterator.html
 **/
class BiDirectionalIterator : public ForwardIterator {};

/**
 * A \e random \e access \e iterator is the STL concept of an iterator that is
 * similar to a BiDirectionalIterator, but allows access to any position in a
 * sequence of data in constant time (\c i[n], \c i+n, \c i-n to access
 * element \c n).
 *
 * \see
 * \ref iterators, http://www.sgi.com/tech/stl/RandomAccessIterator.html
 **/
class RandomAccessIterator : public BiDirectionalIterator {};

/** @} **/


/**
 * @defgroup functionObjects Function Objects
 * A \e function \e object is the STL generalization of an entity that may be
 * executed using zero or more arguments to obtain a value or modify the state
 * of the input data.
 *
 * \see
 * http://www.sgi.com/tech/stl/functors.html
 * @{
 **/

/**
 * \class Generator
 * A \e generator is the STL concept of a function object that takes no
 * arguments.  An ordinary function pointer will work (\c f()), as will an
 * object of a class that defines \c operator().
 *
 * \see
 * UnaryFunc, BinaryFunc, TernaryFunc, http://www.sgi.com/tech/stl/Generator.html, \ref functionObjects
 **/

/**
 * \class UnaryFunc 
 * A \e unary \e function is the STL concept of a function object that takes
 * one argument.  An ordinary function pointer will work (\c f(x)), as will an
 * object of a class that defines \c operator(x).
 *
 * \see
 * Generator, BinaryFunc, TernaryFunc, http://www.sgi.com/tech/stl/UnaryFunction.html, \ref functionObjects
 **/

/**
 * \class BinaryFunc
 * A \e binary \e function is the STL concept of a function object that takes
 * two arguments.  An ordinary function pointer will work (\c f(x,y)), as will
 * an object of a class that defines \c operator(x,y)).
 *
 * \see
 * Generator, UnaryFunc, TernaryFunc, http://www.sgi.com/tech/stl/BinaryFunction.html, \ref functionObjects
 **/

/**
 * \class TernaryFunc
 * A \e tertiary \e function is a function object that takes three arguments.
 * An ordinary function pointer will work (\c f(x,y,z)), as will an object of
 * a class that defines operator(x,y,z).
 *
 * \see
 * TernaryFunc is a STAPL extension to STL's Generator, UnaryFunc and BinaryFunc, \ref functionObjects
 **/

/**
 * \class Predicate
 * A \e predicate is the STL concept of a UnaryFunc that evaluates its
 * argument to \c true or \c false.  For example, a function that takes an
 * integer argument and returns \c true if the argument is positive.
 *
 * \see
 * BinaryPred, http://www.sgi.com/tech/stl/Predicate.html, \ref functionObjects
 **/

/**
 * \class BinaryPred
 * A \e binary \e predicate is the STL concept of a BinaryFunc that evaluates
 * its arguments to \c true or \c false.  For example, a function that takes
 * an two integer arguments and returns \c true if they are both positive.
 *
 * \see
 * Predicate, http://www.sgi.com/tech/stl/BinaryPredicate.html, \ref functionObjects
 **/

/**
 * \class StrictWeakOrdering
 * A \e strict \e weak \e ordering is the STL concept of a BinaryPred that
 * compares two objects and returns \c true if the first should precede the
 * second (e.g, less than).
 *
 * \see
 * http://www.sgi.com/tech/stl/StrictWeakOrdering.html, \ref functionObjects
 **/

/** @} **/


/**
 * \class rand

 * The C++ standard library offers a number of random number generators, of
 * which the function rand is one common example.  It takes no arguments and
 * returns a random number in the range 0 to 2^31 - 1.  To keep track of its
 * current state, it uses a global variable, the seed, which it must lock when
 * used in parallel, hence producing poor performance when used by multiple
 * threads at the same time.  Hence, a statement such as
 *
 * \code
 * pvector<int> v(1000000);
 * p_generate (v.get_prange(), rand);
 * \endcode
 *
 * will correctly generate random numbers in parallel, but will likely require
 * more time than if it was run sequentially.  Luckly, C++ also provides
 * rand_r(int *seed), which solves this problem.  Each thread that needs to
 * create random numbers can simple create its own local seed and use rand_r,
 * eliminating the need for a lock, and hence eliminating the contention.  The
 * examples, especially accumulate.cc, demonstrate the use of rand_r.
 *
 * There are also many other non-portable random number generators available
 * on various platforms.  One good example is drand48, which tends to produce
 * much more "random" results over a larger range of values.  Other generators
 * may be specific to a certain platform or application type (e.g.,
 * encryption).  The user is highly encouraged to determine their specific
 * needs for random number generators and find the best match.
 **/


/** @} **/
