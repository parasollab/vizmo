#ifndef LISTPART_H
#define LISTPART_H

#include "BasePart.h"
/**
 * @ingroup plist
 * @{
 */
namespace stapl {

 /**
  * ListPart class is a wrapper arround the sequential list that implements the 
  * interface specified by BasePart.
  */
template<class T>
class ListPart : public BasePart<T, typename list<splBaseElement<T> >::iterator,
    typename list<splBaseElement<T> >::const_iterator,
    pair<typename list<splBaseElement<T> >::iterator, 
    typename list<splBaseElement<T> >::iterator> > {
      
  public:
      
      //================================================================
      //required typedefs for each part class to instantiate 
      //BasePart and BasePContainer
      //================================================================
      
   ///Element type
   typedef T value_type;
   
   ///Sequential list container
   typedef list<T> Sequential_Container_type;
   typedef list<splBaseElement<T> > Container_type;

   typedef typename list<T>::iterator seq_iterator;
   typedef typename list<T>::const_iterator const_seq_iterator;

   ///Part iterator
   typedef typename list<splBaseElement<T> >::iterator iterator;

   ///Part const iterator
   typedef typename list<splBaseElement<T> >::const_iterator const_iterator;

   typedef pair<iterator,iterator> Element_Set_type;

   //================================================================

   typedef splBaseElement<value_type> BaseElement_type;

   typedef Element_Set_type List_Range_type;
   ///Base class for ListPart
   typedef BasePart<T,iterator,const_iterator, List_Range_type> Base_Part_type;

   //=======================================
   //data
   //=======================================
   ///Sequential List
     Container_type part_data;
     
  public:
     void define_type(typer &t)  {
       cout<<"Define type for list defined but not used"<<endl;
       
       //stapl_assert(1,"plist define_type used.\n");
       //t.local(this->partid);
       //t.local(part_data); 
     }
     
     //test rmi list transfer
     /*   void SendList(PID _pid, const list<BaseElement_type>& _data) { */
     /*     for(const_iterator it = _data.begin(); it!=_data.end(); ++it) { */
     /*       async_rmi(_pid,getHandle(), &ListPart<T>::SetElement, *it); */
     /*     } */
     /*   } */
     
     /*   void SetElement(const BaseElement_type& _d) { */
     /*     if(!part_data.empty) part_data.clear(); */
     /*     part_data.push_back(_d); */
     /*   } */
     
  public:
     //=======================================
     //constructors 
     //=======================================
     /**@brief Default constructor
      */
     ListPart() {
     }
     
     /**@brief Constructor with part identifier specified.
      */
     ListPart(PARTID _id) : Base_Part_type(_id) { 
     }
     
     /**@brief Copy constructor
      */
     ListPart(const ListPart<T>& _list) {
       this->partid = _list.partid;
       part_data = _list.part_data;
     }
     
     /**@brief Copy constructor with part identifier specified.
      */
     ListPart(const ListPart<T>& _list, PARTID _id) {
       this->partid = _id;
       part_data = _list.part_data;
     }
     
     
     ListPart(int m, const vector<GID>& _gidvec, const T& _data, PARTID _id) {
       this->partid = _id;
       list<BaseElement_type> tmp(m,_data);
       part_data = tmp;
       int i=0;
       for(iterator it = part_data.begin(); it!=part_data.end(); ++it, ++i)
	 (*it).SetGid(_gidvec[i]);
     }

     ListPart(int m, const vector<GID>& _gidvec, PARTID _id) {
       this->partid = _id;
       list<BaseElement_type> tmp(m);
       part_data = tmp;
       int i=0;
       for(iterator it = part_data.begin(); it!=part_data.end(); ++it, ++i)
	 (*it).SetGid(_gidvec[i]);
     }
     
     ListPart(const list<BaseElement_type>& _list, PARTID _id) : 
     Base_Part_type(_id) {
       part_data = _list;
     }
     
     
     /**@brief Destructor.
     */
     ~ListPart() {
       part_data.clear();
     }
     
     //=======================================
     //operator
     //=======================================
     /**@brief Assignement operator
      */
     ListPart<T>& operator=(const ListPart<T>& _list) {
       part_data = _list.part_data;
       this->partid = _list.partid;
       return *this;
     }
     
     //=======================================
     //methods required by base part
     //=======================================
     
     /**@brief Add element to part.
      *@param T the element to be added;
      *@param GID associated with the element. The GID is generated by the distribution.
      */
     void AddElement(const T& _t, GID _gid) {
       insert(end(),_t,_gid);
     }
     
      /**@brief Add BaseElement to part.
       *@param T the element to be added;
       *@param GID associated with the element. The GID is generated by the distribution.
       *@Note this method is to be used internally by the pContainer.
       */
     void AddElement(const BaseElement_type& _t, GID _gid) {
       insert(end(),_t.GetUserData(),_gid);
     }
     
     
     virtual T& GetElement(GID _gid) { 
       iterator it;
       if(ContainElement(_gid, &it)) return (*it).GetUserData();
       else throw ElementNotFound(_gid);
     }
     
     virtual const T& GetElement(GID _gid) const { 
       const_iterator it;
       if(ContainElement(_gid, &it)) return (*it).GetUserData();
       else throw ElementNotFound(_gid);
     }

     /**@brief Set the value of an existent element.
      *@param T the element to be added;
      *@param GID associated with the element. The GID is generated by the distribution.
      */
     void SetElement(GID _gid, const T& _t) {
       iterator it;
       if(ContainElement(_gid, &it)) (*it).SetUserData(_t);
       else throw ElementNotFound(_gid);
     }

     /**@brief Delete the element associated with the specified GID
      *@param GID identifier of the element to be deleted.
      */
     void DeleteElement(GID _gid) {
       iterator it;
       if(ContainElement(_gid, &it)) part_data.erase(it);
       else throw ElementNotFound(_gid);
     }

     /**@brief Check if the given gid is local to the part.
      *@param GID identifier of the element to be searched.
      */
     bool ContainElement(GID _gid) {
       iterator it;
       return ContainElement(_gid,&it);
     }


     bool ContainElement(GID _gid, iterator* it) {
       for((*it)=part_data.begin(); (*it)!= part_data.end(); ++(*it)) {
	 if(_gid == (**it).GetGid()) break;
       }
       if((*it) != part_data.end()) return true;
       else {
	 return false;
       }  
     }

     /**@brief Check if the given gid is local to the part.
      *@param iterator will be initialized with the location of the element.
      *@param GID identifier of the element to be searched.
      *@Note. this method should be called after we check if the element is local or not.
      */
     bool ContainElement(GID _gid, const_iterator* it) const {
       for((*it)=part_data.begin(); (*it)!= part_data.end(); ++(*it)) {
	 if(_gid == (**it).GetGid()) break;
       }
       if((*it) != part_data.end()) return true;
       else {
	 return false;
       }  
     }
     
     virtual List_Range_type GetElementSet() const {
       //need const_cast  --ann ???
       /*     List_Range_type lrt(part_data.begin(),part_data.end()); */
       List_Range_type lrt;
       return lrt;
     }

     /**@brief
      *Return a part iterator pointing to the begining of the part.
      */
     iterator begin() {
       return part_data.begin(); 
     }

     /**@brief
      * Return a part iterator pointing to the end of the part.
      */
     iterator end() {
       return part_data.end(); 
     }

     /**@brief
      *Return a part const iterator pointing to the begining of the part.
      */
     const_iterator begin() const {
       return part_data.begin(); 
     }

     /**@brief
      *Return a part const iterator pointing to the end of the part.
      */
     const_iterator end() const {
       return part_data.end(); 
     }

     /**@brief
      *Return the size of the part.
      */
     size_t size() const { return part_data.size(); }

     /**@brief
      *Return if the part is empty or not.
      */
     bool empty() const { return part_data.empty(); }

     /**@brief
      *Erase the elements stored in the local part.
      */
     void clear() { part_data.clear(); }
     
     /**@brief
      *Display part's data. 
      */
     void DisplayPart() const {
       cout << "List Part with ID: "<<this->partid<<" Size: "<<size()
	    <<" Data:"<<endl;
       for(const_iterator it = part_data.begin(); it!= part_data.end(); ++it) {
	 cout<<"("<<(*it).GetGid()<<", "<<(*it).GetUserData()<<"),  ";
       }
       cout<<endl;
     }
     //=======================================
     //methods specific to list part to add, delete, and check element
     //=======================================
     /**@brief
      *Insert an element after at the position specified by the iterator _it.
      *The element will be associated with the specified GID.
      *@param iterator the new element will be added after the element 
      *pointed by this iterator.
      *@param T element to be added.
      *@param GID that will be associated with the element.
      */
     iterator insert(const iterator& _it, const T& _data, GID _gid) {
       BaseElement_type elmt(_gid,_data);
       return part_data.insert(_it, elmt);
     }
     
     /**@brief 
      *Erase the element corresponding to iterator _it.
      *@param iterator pointing to the element to be erased.
      */
     iterator erase(const iterator& _it) {
       return part_data.erase(_it);
     }
     
     //=======================================
     //facility functions
     //=======================================

     /**@brief Return a reference to the data of the part.
      *@return list<BaseElement_type> the data of the part. 
      */
     const list<BaseElement_type>& GetListPart() const { 
       return part_data; 
     }
     
     /**@brief 
      *Get the GIDs stored by this part.
      *@param  vector<GID>& output argument that will contain all the GIDs stored by the part. 
      */
     void GetPartGids(vector<GID>& _gidvec) const { 
       for(const_iterator it=part_data.begin(); it!= part_data.end(); ++it) {
	 _gidvec.push_back((*it).GetGid());
       }
     }
     
     /**@brief 
      *Set part's data.
      *@param list<BaseElement_type> the new data that will be stored by the part.
      *@param PARTID the part identifier for the part.
      */
     void SetListPart(const list<BaseElement_type>& _list, PARTID _id) {
       part_data = _list;
       this->SetPartId(_id);
     }
    };
  
} //end namespace stapl
//@}
#endif
